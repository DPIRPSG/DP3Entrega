Scripts JPQL

1)	Query C/1
	12.7.1 The consumer/s who has/have placed more orders.
	Query: select c from Consumer c join c.orders o group by c having count(c.orders.size) = (select max(c.orders.size) from Consumer c);
	Descripción textual: En esta query hacemos un join de los consumers con sus orders y los agrupamos por los propios consumers. Ahora realizamos un filtro en el que decimos que el count del tamaño de las orders del consumer iguale al máximo del tamaño de orders del consumer.
	Resultado:
	Object #0 = domain.Consumer{
		id=13
		version=1
		name="Ruben"
		surname="Sanchez"
		email="ruben@mail.com"
		phone="612342289"
		folders=[domain.Folder@20, domain.Folder@21, domain.Folder@22]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@5
		shoppingCart=domain.ShoppingCart@e
		orders=[domain.Order@4e, domain.Order@50, domain.Order@53]
	} 
	Object #1 = domain.Consumer{
		id=15
		version=1
		name="Guillermo"
		surname="Alcala"
		email="guillermo@mail.com"
		phone="633422897"
		folders=[domain.Folder@23, domain.Folder@24, domain.Folder@25]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@6
		shoppingCart=domain.ShoppingCart@10
		orders=[domain.Order@4f, domain.Order@51, domain.Order@52]
	} 

2)	Query C/2
	12.7.2 The consumer/s who has/have spent more money on their orders.
	Query: select c from Consumer c join c.orders o where o.cancelMoment is null group by c having max(o.amount) = (select max(o.amount) from Order o);
	Descripción textual: En esta query hacemos un join de los consumers con sus orders y filtramos las orders si éstas no tienen cancelMoment. Agrupamos por los consumer y volvemos a filtrar esta vez por el maximo del amount de las orders que sean iguales al amount máximo de las orders. 
	Resultado:
	Object #0 = domain.Consumer{
		id=13
		version=1
		name="Ruben"
		surname="Sanchez"
		email="ruben@mail.com"
		phone="612342289"
		folders=[domain.Folder@20, domain.Folder@21, domain.Folder@22]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@5
		shoppingCart=domain.ShoppingCart@e
		orders=[domain.Order@4e, domain.Order@50, domain.Order@53]
	} 

3)	Query C/3
	12.7.3 The best-selling item/s in the inventory.
	Query: select i from Item i where i.deleted is false and i.sku IN (select oi.sku from OrderItem oi join oi.order o where o.deliveryMoment is not null group by oi.sku having max(oi.units) = (select max(oi.units) from OrderItem oi));
	Descripción textual: En esta query seleccionamos el item que no haya sido marcado como borrado y cuyo sku esté dentro del resultado de otra función. Esta otra funcion recupera el sku del OrderItem que no provenga de un order que no haya sido entregado agrupando por el sku teniendo el máximo de unidades de ese order item igual al máximo de unidades de un orderItem.
	Resultado:
	Object #0 = domain.Item{
		id=52
		version=0
		sku="AB-H6GH"
		name="Turrón de chocolate"
		description="se acerca la navidad, compra el mejor turron de chocolate"
		price=1.99
		tags=[Dulce, Turron, Chocolate]
		picture=<null>
		deleted=<<false>>
		category=domain.Category@31
		comments=[domain.Comment@39]
		storages=[domain.Storage@43]
	}

4)	Query C/4
	12.7.4 The worst-selling item/s in the inventory.
	Query: select i from Item i where i.deleted is false and i.sku IN (select oi.sku from OrderItem oi join oi.order o where o.deliveryMoment is not null group by oi.sku having min(oi.units) = (select min(oi.units) from OrderItem oi));
	Descripción textual: En esta query seleccionamos el item que no haya sido marcado como borrado y cuyo sku esté dentro del resultado de otra función. Esta otra funcion recupera el sku del OrderItem que no provenga de un order que no haya sido entregado agrupando por el sku teniendo el mínimo de unidades de ese order item igual al mínimo de unidades de un orderItem.

	Resultado:
	Object #0 = domain.Item{
		id=53
		version=0
		sku="CJ-C8JW"
		name="Televisor"
		description="El mejor televisor para las mejores series"
		price=699.99
		tags=[TV, Full-HD, Smart-TV]
		picture=<null>
		deleted=<<false>>
		category=domain.Category@32
		comments=[domain.Comment@3a]
		storages=[domain.Storage@44]
	} 
	Object #1 = domain.Item{
		id=55
		version=0
		sku="Vl-3H95"
		name="Filete de cerdo"
		description="Filete bueno y barato"
		price=3.5
		tags=[Filete, Cerdo, Carne]
		picture=<null>
		deleted=<<false>>
		category=domain.Category@31
		comments=[domain.Comment@3d, domain.Comment@3e]
		storages=[domain.Storage@46]
	} 

5)	Query B/1
	17.6.1 The clerk/s who has/have served and delivered more orders.
	Query: select c1 from Order o1 join o1.clerk c1 where o1.deliveryMoment is not null group by c1 having count(o1) >= all(select count(o2) from Clerk c2 join c2.orders o2 where o2.deliveryMoment is not null group by c2);
	Descripción textual: En esta query tomamos el clerk filtrando las orders que no hayan sido entregadas. Agrupamos por el clerk y filtramos si el número de orders es mayor o igual al resultado de la select que devuelve el número de orders que no tengas fecha de entrega, agrupando de nuevo por clerk.
	Resultado:
	Object #0 = domain.Clerk{
		id=20
		version=0
		name="Ana"
		surname="pozo"
		email="ana@mail.com"
		phone="633946087"
		folders=[domain.Folder@26, domain.Folder@27, domain.Folder@28]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@7
		orders=[domain.Order@4e, domain.Order@50, domain.Order@52, domain.Order@55]
	} 

6)	Query B/2
	17.6.2 The clerk/s who has/have served and delivered less orders.
	Query: select c1 from Order o1 join o1.clerk c1 where o1.deliveryMoment is not null group by c1 having count(o1) <= all(select count(o2) from Clerk c2 join c2.orders o2 where o2.deliveryMoment is not null group by c2);
	Descripción textual: En esta query tomamos el clerk filtrando las orders que no hayan sido entregadas. Agrupamos por el clerk y filtramos si el número de orders es menor o igual al resultado de la select que devuelve el número de orders que no tengas fecha de entrega, agrupando de nuevo por clerk.

	Resultado:
	Object #0 = domain.Clerk{
		id=19
		version=0
		name="Carlos"
		surname="Mata"
		email="carlos@mail.com"
		phone="633449087"
		folders=[domain.Folder@1d, domain.Folder@1e, domain.Folder@1f]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@4
		orders=[domain.Order@4d, domain.Order@51, domain.Order@54]
	} 
	Object #1 = domain.Clerk{
		id=21
		version=0
		name="Alberto"
		surname="Rodriguez"
		email="alberto@mail.com"
		phone="633940257"
		folders=[domain.Folder@29, domain.Folder@2a, domain.Folder@2b]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@8
		orders=[domain.Order@4f, domain.Order@53]
	}

7)	Query B/3
	17.6.3 The consumer/s who has/have cancelled more orders.
	Query: select c1 from Order o1 join o1.consumer c1 where o1.cancelMoment is not null group by c1 having count(o1) >= all(select count(o2) from Consumer c2 join c2.orders o2 where o2.cancelMoment is not null group by c2);
	Descripción textual: En esta query tomamos el consumer filtrando las order que no tengan una fecha de cancelación. Agrupamos por el consumer y filtramos si el número de orders es mayor o igual al resultado de la select que devuelve el número de order cuya que no tengan fecha de cancelación, agrupando de nuevo por clerk.
	Resultado:
	Object #0 = domain.Consumer{
		id=15
		version=1
		name="Guillermo"
		surname="Alcala"
		email="guillermo@mail.com"
		phone="633422897"
		folders=[domain.Folder@23, domain.Folder@24, domain.Folder@25]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@6
		shoppingCart=domain.ShoppingCart@10
		orders=[domain.Order@4f, domain.Order@51, domain.Order@52]
	} 

8)	Query B/4
	17.6.4 Display a dashboard with the following information: The consumer/s who has/have cancelled less orders.
	Query: select c1 from Order o1 join o1.consumer c1 where o1.cancelMoment is not null group by c1 having count(o1) <= all(select count(o2) from Consumer c2 join c2.orders o2 where o2.cancelMoment is not null group by c2);
	Descripción textual: En esta query tomamos el consumer filtrando las order que no tengan una fecha de cancelación. Agrupamos por el consumer y filtramos si el número de orders es menor o igual al resultado de la select que devuelve el número de order cuya que no tengan fecha de cancelación, agrupando de nuevo por clerk.
	Resultado:
	Object #0 = domain.Consumer{
		id=13
		version=1
		name="Ruben"
		surname="Sanchez"
		email="ruben@mail.com"
		phone="612342289"
		folders=[domain.Folder@20, domain.Folder@21, domain.Folder@22]
		sent=[]
		received=[domain.Message@16]
		userAccount=security.UserAccount@5
		shoppingCart=domain.ShoppingCart@e
		orders=[domain.Order@4e, domain.Order@50, domain.Order@53]
	} 

9)	Query B/5
	17.6.5 Display a dashboard with the following information: The ratio of orders that have been cancelled during the current month.
	Query: select (count(distinct o1)*1.0)/(count(distinct o2)*1.0) from Order o1, Order o2 where month(o1.cancelMoment) = month(CURRENT_DATE) and year(o1.cancelMoment) = year(CURRENT_DATE) and month(o2.placementMoment) = month(CURRENT_DATE) and year(o2.placementMoment) = year(CURRENT_DATE);
	Descripción textual: En esta query obtenemos el resultado de la división entre las order que se hayan cancelado este mes y las que se hayan creado en el mismo. Filtramos si el mes y año de cancelación no es igual al mes y año del momento actual. Realizamos también otro filtro en el que el mes y año de creación de un order tampoco sea el del momento actual. Realizamos una multiplicación de 1.0 para que no trunque el resultado a las unidades.
	Resultado:
	Object #0 = java.lang.Double{0.66667} 

10)	Query A/1
	25.2.1 Display a dashboard with the following information: The item/s that has/have more comments.
	Query: select i from Item i where i.deleted is false and i.comments.size = (select max(i.comments.size) from Item i where i.deleted is false) group by i;
	Descripción textual: En esta query tomamos el item que no haya sido borrado y que tenga el el tamaño del conjunto de comentarios igul al del item con mayor número de comentarios. Finalmente agrupamos los resultados por su item.
	Resultado:
	Object #0 = domain.Item{
		id=54
		version=0
		sku="9G-H58D"
		name="Colonia"
		description="Colonia de mujer"
		price=10.9
		tags=[Colonia]
		picture=<null>
		deleted=<<false>>
		category=domain.Category@33
		comments=[domain.Comment@3b, domain.Comment@3c]
		storages=[domain.Storage@45]
	} 
	Object #1 = domain.Item{
		id=55
		version=0
		sku="Vl-3H95"
		name="Filete de cerdo"
		description="Filete bueno y barato"
		price=3.5
		tags=[Filete, Cerdo, Carne]
		picture=<null>
		deleted=<<false>>
		category=domain.Category@31
		comments=[domain.Comment@3d, domain.Comment@3e]
		storages=[domain.Storage@46]
	}